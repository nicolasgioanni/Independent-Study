# Implementation for Extraction Attack: Copycat CNN (Correia-Silva et al., 2018)

import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.utils import to_categorical
from art.estimators.classification import TensorFlowV2Classifier
from art.utils import load_dataset

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test), min_, max_ = load_dataset('mnist')
x_train = x_train.reshape((x_train.shape[0], 28, 28, 1)).astype("float32") / 255.0
x_test = x_test.reshape((x_test.shape[0], 28, 28, 1)).astype("float32") / 255.0

# Apply one-hot encoding only if labels are not already in that format
if y_train.ndim == 1:
    y_train = to_categorical(y_train, 10)
if y_test.ndim == 1:
    y_test = to_categorical(y_test, 10)

# Print shapes to confirm dimensions
print("Final shape of x_train:", x_train.shape)    # Expected: (60000, 28, 28, 1)
print("Final shape of y_train:", y_train.shape)    # Expected: (60000, 10)
print("Final shape of x_test:", x_test.shape)      # Expected: (10000, 28, 28, 1)
print("Final shape of y_test:", y_test.shape)      # Expected: (10000, 10)

# Define the model architecture
def create_model():
    model = Sequential([
        Flatten(input_shape=(28, 28, 1)),
        Dense(128, activation='relu'),
        Dense(64, activation='relu'),
        Dense(10, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Initialize and train the target model
target_model = create_model()
target_model.fit(x_train, y_train, batch_size=128, epochs=5, validation_split=0.1)

# Wrap the model with ART's classifier
classifier = TensorFlowV2Classifier(
    model=target_model,
    loss_object=tf.keras.losses.CategoricalCrossentropy(),
    input_shape=(28, 28, 1),
    nb_classes=10,
    clip_values=(0, 1)
)

# Generate synthetic labels for "unlabeled" data using the target model
unlabeled_data = x_test[:100]
synthetic_labels = target_model.predict(unlabeled_data)
synthetic_labels = np.argmax(synthetic_labels, axis=1)
synthetic_labels = to_categorical(synthetic_labels, 10)

# Train the Copycat model using the synthetic labeled data
copycat_model = create_model()
copycat_model.fit(unlabeled_data, synthetic_labels, batch_size=10, epochs=5, validation_split=0.1)

# Evaluate the Copycat model on the test set
copycat_accuracy = copycat_model.evaluate(x_test, y_test, verbose=0)[1]
print(f"Copycat Model Test Accuracy: {copycat_accuracy * 100:.2f}%")

# Evaluate the target model on the test set for comparison
target_accuracy = target_model.evaluate(x_test, y_test, verbose=0)[1]
print(f"Target Model Test Accuracy: {target_accuracy * 100:.2f}%")

'''
NOTE
Copycat Model Test Accuracy: 10.84% 
    - This lower accuracy is expected, as the Copycat model was trained on a small subset 
    of synthetic labeled data generated by the target model, which limits its performance.
Target Model Test Accuracy: 90.41% 
    - This accuracy demonstrates that the target model performed well on the test set.
'''